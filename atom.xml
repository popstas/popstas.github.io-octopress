<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Popstas]]></title>
  <link href="http://blog.popstas.ru/atom.xml" rel="self"/>
  <link href="http://blog.popstas.ru/"/>
  <updated>2016-03-26T03:08:29+05:00</updated>
  <id>http://blog.popstas.ru/</id>
  <author>
    <name><![CDATA[Stanislav Popov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CHANGELOG.md: ручное и автоматическое ведение истории изменений проекта в Git]]></title>
    <link href="http://blog.popstas.ru/blog/2016/03/06/changelog-dot-md-generate-from-git-conventions/"/>
    <updated>2016-03-06T10:09:13+05:00</updated>
    <id>http://blog.popstas.ru/blog/2016/03/06/changelog-dot-md-generate-from-git-conventions</id>
    <content type="html"><![CDATA[<p>С начала января я веду свой <a href="http://blog.popstas.ru/blog/2016/01/17/torrent-transmission-client-for-weburg/">проектик</a>, на котором обкатываю новые для меня технологии:</p>

<ul>
<li>Статический анализ кода, phpcs, phpmd, Scrutinizer</li>
<li>Автоматическая сборка, Travis CI</li>
<li>Unit тесты, PHPUnit</li>
<li>Покрытие кода, Coveralls</li>
<li>Работу через задачи для любых изменений, Github Issues, PhpStorm tasks</li>
<li>Документирование всего: README, CHANGELOG, сайт проекта, &ndash;help</li>
</ul>


<p>В этом посте изложена история изменений моего мнения о разных генераторах историй изменения.</p>

<p>Tl;dr: conventional-changelog, стандартизация коммитов.</p>

<p><img src="http://blog.popstas.ru/images/2016-03/changelog.png"></p>

<!-- more -->


<h1>CHANGELOG.md</h1>

<p>Понятная для человека история изменений проекта нужна. Тут надо заметить что такими историями не являются:</p>

<ul>
<li>Issues проекта, ветка в менеджере задач, доска проекта и т.п.</li>
<li>git log проекта</li>
</ul>


<p>Файл CHANGELOG.md в корне проекта стал стандартом де-факто для проектов, в котором ведется история изменений, Gitlab даже делает для него отдельную вкладку на странице репозитория.</p>

<p>Про это, конечно, есть <a href="http://keepachangelog.com/">сайт</a>, <a href="https://github.com/olivierlacan/keep-a-changelog">репозиторий на Github</a> с тысячей звезд, проблема явно беспокоит людей.</p>

<p>Про ведение CHANGELOG я задумался, когда изучал проект <a href="https://github.com/hashicorp/otto/">otto</a>, когда писал про него <a href="http://habrahabr.ru/post/273009/">статью на хабр</a>.</p>

<h4>Структура у CHANGELOG более-менее у всех одна и та же:</h4>

<ul>
<li>Версия и дата релиза</li>
<li>Сломанные обратные совместимости</li>
<li>Новые фичи</li>
<li>Прочие изменения и улучшения</li>
<li>Исправленные баги</li>
</ul>


<p>Вести такой документ достаточно просто, я за 120 коммитов почти не забывал это делать. В файле нужно всегда держать вверху секцию Next Release с подготовленными заголовками, как-то так:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>## Next Release
</span><span class='line'>
</span><span class='line'>BREAKING CHANGES:
</span><span class='line'>
</span><span class='line'>FEATURES:
</span><span class='line'>
</span><span class='line'>IMPROVEMENTS:
</span><span class='line'>
</span><span class='line'>BUG FIXES:</span></code></pre></td></tr></table></div></figure>


<p>Перед коммитом я всегда просматриваю дифф, в это время я записываю в коммент к коммиту кратко изменение в первую строку и более подробно в третью, если изменений больше одного, делаю в виде списка. Если про это есть задача, нужно упомянуть ее в виде #123 ссылки, Github умный и такие ссылки делает активными.</p>

<p>Так вот, нужно просто добавить в этот процесс копипасту коммента к коммиту в CHANGELOG, с раскладыванием по категориям изменений.</p>

<p>Во время релиза называем секцию, ставим ей дату, копипастим заголовки.</p>

<p>Процедура очень простая, настолько простая, что хочется ее поручить роботу.</p>

<h2>github_changelog_generator</h2>

<p><a href="https://github.com/skywinder/github-changelog-generator">github_changelog_generator</a> - ruby утилита, которая умеет генерировать CHANGELOG.md из любого репозитория. На выходе получаем документ типа <a href="https://github.com/skywinder/github-changelog-generator/blob/master/CHANGELOG.md">этого</a>, наполненный ссылками на задачи и пулл-реквесты, разбитый по категориям, все круто, как в рекламе. У меня получилось совсем не так красиво.</p>

<p>Что мне не понравилось в этом генераторе:</p>

<ul>
<li>Текст коммитов никак не учитывает, как и текст задач.</li>
<li>Чтобы она нормально работала, нужно по полной использовать Github Issues и метки для них, пулл-реквесты, в общем сильно завязано на Github (кто бы мог подумать?), иначе будут генериться просто ссылки на диффы между тегами.</li>
<li>Нельзя указывать свои секции (например, Breaking changes встроенного нет), но есть <a href="https://github.com/skywinder/github-changelog-generator/issues/316">issue #316</a> про это, судя по активности проекта, они скоро появятся.</li>
</ul>


<p>Что понравилось:</p>

<ul>
<li>Поведение из коробки что-то генерирует, даже если вы не думали про CHANGELOG.md до этого и не использовали Github фишки, это лучше, чем ничего. Но не намного.</li>
<li>Можно привязывать свои метки к существующим секциям лога.</li>
<li>Можно настраивать как параметрами к команде, так и конфигом. При запуске скрипт говорит: <code>Performing task with options</code>, так вот, каждую строку из перечисленного ниже конфига можно вставить в файл <code>.github_changelog_generator</code> и переопределить, заменив <code>_</code> на <code>-</code>.</li>
<li>Поддерживает сосуществование заполняемой вручную версии (которая все равно лучше автоматической) и генерируемого лога, для этого нужно переложить старый CHANGELOG.md в HISTORY.md (или другой файл, указав его в конфиге).</li>
</ul>


<p>В общем, github_changelog_generator в моем случае подходит хорошо,
если вся работа ведется на Github, это самый простой способ получить красивый CHANGELOG.md</p>

<p>Но на этом я не успокоился, основная причина в том, что на рабочие проекты на Github я не делаю. Хотелось более общего решения.</p>

<h2>git-extras changelog</h2>

<p><a href="https://github.com/tj/git-extras">tj/git-extras</a> - это <a href="https://github.com/tj/git-extras/blob/master/Commands.md">огромный</a> (около 50) пакет дополнительных команд, упрощающих работу с git. Я его раньше уже видел, но в то время подумал, что мне и встроенных в git команд слишком много. Но в поисках генератора снова набрел на него, у него есть такая команда.</p>

<p>Вот таким нехитрым способом можно в одну команду сгенерировать и запушить лог для проекта, где его не было, но версии помечались тегами и комменты к коммитам были осмысленными:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git changelog -a -p -x &gt; CHANGELOG.md && git add CHANGELOG.md && git commit CHANGELOG.md -m "add CHANGELOG.md" && git push origin master</span></code></pre></td></tr></table></div></figure>


<p>Для пробы сделал лог для <a href="https://github.com/popstas/site-setup/blob/5cb4f52bfc5909bac8b8bc77540cf3283b94ff2a/CHANGELOG.md">site-setup</a>, <a href="https://github.com/popstas/server-scripts/blob/009d82420fa4623417cf437b00df36c662c759a2/CHANGELOG.md">server-scripts</a>, <a href="https://github.com/popstas/drupal-scripts/blob/b0b7a5907798ebde714471fbf1611c3232df5925/CHANGELOG.md">drupal-scripts</a>, на этом успокоился, больше в общем и тестить не на чем.</p>

<p>Ниже я отказался от него в пользу <code>conventional changelog</code>.</p>

<h4>Плюсы:</h4>

<ul>
<li>Простой как дверь, выполняешь команду, получаешь список изменений, разделенных версиями</li>
</ul>


<h4>Минусы:</h4>

<ul>
<li>Нет почти никаких настроек</li>
</ul>


<h2>rafinskipg/git-changelog</h2>

<p><a href="https://github.com/rafinskipg/git-changelog">rafinskipg/git-changelog</a> - node.js cкрипт, который парсит коммиты, написанные по <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#">стандартам Angular</a>. Я их прочитал, оказалось, что стандарты годные, к angular никак не привязаны.</p>

<p>Конфликтует с git-extras, так как оба они хотят называться git-changelog. Этот я сделал симлинком <code>git-changelog-angular</code>.</p>

<p>Параметров у скрипта немного, я с ними поигрался, но ничего хорошего у меня с этим тулом не вышло. Идем дальше.</p>

<h2>conventional-changelog</h2>

<p><a href="https://github.com/stevemao/conventional-changelog-cli">stevemao/conventional-changelog-cli</a> - node.js скрипт, также нацелен на стандарты Angular, но, <a href="https://github.com/stevemao/conventional-changelog-cli#why">по заявлениям</a> авторов это как раз то, что нужно:</p>

<ul>
<li>поддерживает свои форматы коммитов и несколько общих: &lsquo;angular&rsquo;, &lsquo;atom&rsquo;, &lsquo;codemirror&rsquo;, &lsquo;ember&rsquo;, &lsquo;eslint&rsquo;, &lsquo;express&rsquo;, &lsquo;jquery&rsquo;, &lsquo;jscs&rsquo;, &lsquo;jshint&rsquo;</li>
<li>поддерживает шаблоны</li>
<li>протестирован, в отличие от github_changelog_generator</li>
<li>отвязан от Github</li>
<li>имеет модульную структуру и несколько модулей вокруг себя</li>
</ul>


<p>Воспользовавшись <code>conventional-commits-detector</code>, узнал, что мои комменты к коммитам больше всего похожи на стандарт <code>eslint</code>.</p>

<p>Сгенерированный лог дал понять, что в eslint принято указывать категорию и через двоеточие суть, так коммиты в релизе разбиваются по категориям. Но в целом, конечно, коммиты были названы неправильно и хорошего лога не получилось.</p>

<p>Зато запуск без указания пресета сообщений выдал почти то же, что и <code>git-extras</code>, но вдобавок к этому задал мажорным и минорным версиям разный уровень и указал ссылку на коммит на Github для каждого коммита.</p>

<p>Сгенерировать лог с нуля можно командой:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>conventional-changelog -i CHANGELOG.md -s -r 0</span></code></pre></td></tr></table></div></figure>


<p>После этого я конечно побежал исправлять логи у проектов, которым сделал логи час назад, вот что вышло: <a href="https://github.com/popstas/site-setup/blob/fd159ed7848aaf8695642bcb53c795922d307dd6/CHANGELOG.md">site-setup</a>, <a href="https://github.com/popstas/server-scripts/blob/ef6138faf0179f31929ff0d90d98466749d4f85b/CHANGELOG.md">server-scripts</a>, <a href="https://github.com/popstas/drupal-scripts/blob/3eb923c09e319a163f9fea9669dfa735b60044c1/CHANGELOG.md">drupal-scripts</a>.</p>

<p>Дальше искать не стал, думаю это оно самое.</p>

<p>Кроме лучшего результата из коробки и полной кастомизации мне в нем понравились модули:</p>

<ul>
<li><a href="https://github.com/ajoslin/angular-precommit">angular-precommit</a> - готовый валидатор сообщений к коммитам</li>
<li><a href="https://github.com/marionebl/conventional-changelog-lint">conventional-changelog-lint</a> - скрипт для pre-commit хука, проверяющий сообщения коммитов на соответствие стандартам, стандарты описываются в файле</li>
<li><a href="https://github.com/stevemao/conventional-github-releaser">conventional-github-releaser</a> - автоматическое создание релизов на Github. У меня они уже создаются, но приходится вручную заходить туда и править сообщение к релизу</li>
</ul>


<hr />

<h1>Выводы</h1>

<p>Для того, чтобы генератор создавал по-настоящему хорошие логи, важно определиться с форматом сообщений к коммитам, научиться следовать ему и научить роботов понимать наш формат, чтобы роботы <del>поработили людей</del> помогали правильно и не напрягаясь вести историю изменеий проекта в процессе, а не после работы над проектом.</p>

<p>Для себя я нашел инструмент, которым я теперь могу за 5 минут создавать историю изменений для проектов на основе коммитов.</p>

<p>Генерация CHANGELOG.md - шаг в сторону хорошей и актуальной документации по проекту, которая не будет занимать часы или дни, она будет частью рабочего процесса, конечно для маленького проекта из одного программиста это избыточно, мягко говоря, но надо же с чего-то начинать.</p>

<h2>UPD 08.03.2016</h2>

<p>Добавил валидатор:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>npm install -g conventional-changelog-lint
</span><span class='line'>echo 'conventional-changelog-lint -e' &gt; .git/hooks/commit-msg
</span><span class='line'>chmod +x .git/hooks/commit-msg</span></code></pre></td></tr></table></div></figure>


<p>После этого коммиты с неправильными сообщениями перестанут проходить.</p>

<p>Перед релизом генерирую CHANGELOG.md:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>conventional-changelog -p angular -i CHANGELOG.md -s </span></code></pre></td></tr></table></div></figure>


<p>Это допишет в лог содержимое коммитов с последнего релиза (semver тега). После этого остается поправить руками то, что не нравится, проставить версию.</p>

<p>После этого я генерирую документацию специфичной для проекта командой, коммит, тег, пуш:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m 'docs: v0.6.0'
</span><span class='line'>git push --follow-tags</span></code></pre></td></tr></table></div></figure>


<p>После этого релиз. Релиз будем делать через <code>conventional-github-releaser</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>npm install -g conventional-github-releaser
</span><span class='line'>CONVENTIONAL_GITHUB_RELEASER_TOKEN=your_public_repo_token conventional-github-releaser -p angular</span></code></pre></td></tr></table></div></figure>


<p>Еще не разобрался с тем, как это скрестить с выкладкой PHAR архива с Travis: для <code>github-releaser</code> нужно, чтобы релиза еще не было, но он создается автоматически при пуше тега на Github. После удаления релиза (превращения в Draft), github-releaser отработал, вставил данные CHANGELOG в релиз, все как надо.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Интеграция Git, Gitlab и Planfix почти как на Github]]></title>
    <link href="http://blog.popstas.ru/blog/2016/03/02/git-gitlab-planfix-integration/"/>
    <updated>2016-03-02T00:49:29+05:00</updated>
    <id>http://blog.popstas.ru/blog/2016/03/02/git-gitlab-planfix-integration</id>
    <content type="html"><![CDATA[<p>Распробовал тут на неделе интеграцию задач Github и самого Git issue tracker.</p>

<p>Ниже будет написано, как настроить в <a href="https://planfix.ru/">Планфиксе</a> такое поведение:</p>

<ul>
<li>В коммите упоминаем задачу, например, <code>Правки футера шаблона, https://test.planfix.ru/task/123456</code></li>
<li>После push в удаленный репозиторий в упомянутой задаче появляется комментарий с текстом коммита и ссылкой на страницу коммита на Gitlab, если проект подключен к репозиторию.</li>
</ul>


<p>Tl;dr: настраивается post-receive hook в Git на удаленном сервере, после каждого пуша анализируются сообщения пришедших коммитов, коммиты, содержащие ссылки на задачи отправляются в задачи по email.</p>

<p>Вся интеграция делается в одном файле, код хука лежит здесь - <a href="https://github.com/popstas/server-scripts/blob/master/bin/git-hook-post-receive">git-hook-post-receive</a></p>

<p><img src="http://blog.popstas.ru/images/2016-03/planfix_logo.png"></p>

<!-- more -->


<p>Здесь надо в 2 словах рассказать о нашем workflow:</p>

<ul>
<li>Компания занимается разработкой и поддержкой около 100 сайтов.</li>
<li>Каждый сайт использует Git, репозиторий лежит прямо в корне сайта, bare репозитории отсутствуют.</li>
<li>Часто бывают мелкие правки на разных сайтах.</li>
<li>90% сайтов на Drupal 7, в котором половина хранится в базе данных.</li>
<li>Во время правки контент-менеджер или клиент могут пользоваться сайтом и менять на нем данные</li>
<li>Разработчик выкачивает проект в PhpStorm, настаивает сохранение по Ctrl+S изменений на боевом сайте, таким образом получается, что когда приходит время пушить, на удаленном сервере фактически уже есть все изменения.</li>
<li>Разработчик также может напрямую править код сайта на удаленном сервере по SFTP, не выкачивая проект, после чего зайти по SSH на удаленный сервер и сделать коммит прямо оттуда.</li>
<li>Git по сути используется не для доставки изменений на боевой сайт, а для их доставки на компы разработчиков и ведения журнала изменений сайта.</li>
</ul>


<h2>Github issues</h2>

<p>Кто не знает про issues гитхаба, расскажу вкратце о его фишках:</p>

<ul>
<li>В задачах можно ссылаться на коммиты и другие задачи по номерам, они автоматически становятся ссылками.</li>
<li>В коммитах можно ссылаться на задачи так же: <code>#123</code>, такой коммит автоматом упоминается в задаче.</li>
<li>В PhpStorm можно смотреть список открытых issues и создавать из них задачи в IDE, что позволяет автоматом создавать чейнджлист, ветку для выполнения задачи, в коммите сразу будет ссылка на задачу (это все по желанию).</li>
<li>Можно закрывать задачу прямо из коммита, для этого достаточно упомянуть его рядом с одним из ключевых слов, например, <code>closes #123</code> после пуша в гитхаб закроет указанную задачу.</li>
</ul>


<p>А главное, что все связано и из любого места можно перейти на связанные действия.</p>

<p>Я уже краем уха слышал и видел обо всем этом и видел в чужих репозиториях, но вся картина нарисовалась только после использования. Да и к тому же на гитхабе до этого сталкивался только с pull-request'ами, там немного другое поведение.</p>

<h2>PhpStorm tasks</h2>

<p>В PhpStorm есть интеграция с менеджерами задач, Github там конечно есть, Планфикса там конечно нет, но зато если у менеджера задач есть API, можно интегрировать неподдерживаемый сервис. У Планфикса API есть, но из коробки он не подойдет для этой интеграции, нужно писать свои обертки. В общем-то это дает не много, всего лишь можно будет получать список задач по команде из шторма, и дописывать в коммит ссылку на задачу.</p>

<p>Кстати таски в шторме помогают и без интеграции с трекером: Ctrl+Shift+A - open task, автоматом чистятся все вкладки (создается контекст задачи), создается ветка в гите, changelist, по close task - коммит, я недавно начал пользоваться.</p>

<p>Но гораздо интереснее интеграция в другую сторону: ссылки из задач на коммиты.</p>

<p>Когда я разобрался с тем, как устроена интеграция задач в гитхабе, до меня быстро дошло: просто менеджер задач должен уметь парсить текст коммита, приходящий из гита и делать на основе этого какие-то действия. С этим тоже пока облом: в Планфиксе на данный момент нет обработки писем, прилетающих в задачи, зато <a href="https://planfix.ru/docs/%D0%9A%D0%B0%D0%BA_%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D1%8C_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D1%83_%D0%BF%D0%BE_e-mail%3F">есть обработка писем</a>, приходящих на email юзера, что позволяет надеяться на появление обработки писем, приходящих на email задачи.</p>

<h2>Gitlab</h2>

<p>Самые активные проекты мы дублируем на наш внутренний Gitlab. Использование довольно извращенное, Gitlab сейчас никак не участвует в рабочем процессе, являясь просто зеркалом и веб-интерфейсом для просмотра коммитов.</p>

<p>На машине разработчика настраивается <code>pre-push</code> хук, который пушит также в Gitlab:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>
</span><span class='line'>remote="$1"
</span><span class='line'>
</span><span class='line'>if [ "$remote" != "gitlab" ] && [ "$(git remote show | grep -c "gitlab")" = 1 ]; then
</span><span class='line'>        git push gitlab master
</span><span class='line'>fi</span></code></pre></td></tr></table></div></figure>


<h2>Git и Planfix</h2>

<p>Никакой готовой интеграции между Git и Планфиксом нет, зато обе системы гибкие и позволяют лепить уникальные решения без больших усилий.</p>

<p>Git поддерживает хуки: скрипты, запускающиеся по определенным событиям.</p>

<p>У каждой задачи в Планфиксе есть свой email адрес, если послать на него письмо, оно придет в задачу в виде комментария, если с email отправителя связан пользователь, то письмо придет как будто от него.</p>

<p>Значит нам нужно отправлять email из Git в Планфикс на адрес задачи.</p>

<h1>Связываем все вместе</h1>

<p>Вся интеграция делается в одном файле, код хука лежит здесь - <a href="https://github.com/popstas/server-scripts/blob/master/bin/git-hook-post-receive">git-hook-post-receive</a></p>

<p>Чтобы подключить хук, надо положить скрипт в папку <code>.git/hooks/post-receive</code> и сделать его исполняемым, для этого надо выполнить в корне проекта:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -s "https://raw.githubusercontent.com/popstas/server-scripts/master/bin/average" &gt; .git/hooks/post-receive
</span><span class='line'>chmod +x .git/hooks/post-receive</span></code></pre></td></tr></table></div></figure>


<p>Так как у нас много проектов, я храню его в отдельной общей папке, а в каждом репозитории создаю символическую ссылку на него.</p>

<p>Хук получает список коммитов, пришедших с последним пушем, находит первую ссылку на задачу Планфикса и отправляет туда письмо.</p>

<h4>О письме</h4>

<ul>
<li><strong>Отправитель</strong>: email того, кто сделал коммит. По этой причине email в git config и email в профиле юзера Планфикса должны совпадать.</li>
<li><strong>Получатель</strong>: email задачи Планфикса</li>
<li><strong>Тема письма</strong>: <code>@commit @nonotify</code>, @nonotify для того, чтобы не уведомлять всех участников задачи о коммите, <code>@commit</code> ничего не значит, может быть потом пригодится для поиска таких комментов, хотя в отчетах текст комментария все равно использовать нельзя.</li>
<li><strong>Текст письма</strong>: текст коммита. Если репозиторий имеет зеркало на Gitlab, то в конец текста будет добавлена ссылка на коммит.</li>
</ul>


<p>Чтобы хук добавлял ссылку на Gitlab, не придумал ничего лучше, чем добавить remote <code>gitlab</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git remote add gitlab ssh://git@org.ru:10022/sites/test.ru.git</span></code></pre></td></tr></table></div></figure>


<p>После этого хук будет извлекать из этого адреса URL <a href="http://org.ru/sites/test,">http://org.ru/sites/test,</a> который является главной страницей репозитория. Сайт при всем при этом не имеет доступа к Gitlab, поэтому push и pull в этот remote работать не будут.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Average: измерение среднего времени выполнения команды в Bash]]></title>
    <link href="http://blog.popstas.ru/blog/2016/02/29/average-time-of-script-execution-in-bash/"/>
    <updated>2016-02-29T03:46:56+05:00</updated>
    <id>http://blog.popstas.ru/blog/2016/02/29/average-time-of-script-execution-in-bash</id>
    <content type="html"><![CDATA[<p>Периодически хочется посчитать среднее время, у меня были такие сценарии:</p>

<ul>
<li>простая проверка скорости загрузки страницы</li>
<li>подбор оптимальных параметров к команде</li>
<li>сравнение разных команд</li>
</ul>


<p>Раньше я просто запускал несколько раз с <code>time</code>, смотрел результат, у уме делил.
Но мне это надоело, поэтому написал скрипт <code>average</code>.</p>

<!-- more -->


<p>Код лежит здесь - <a href="https://github.com/popstas/server-scripts/blob/master/bin/average">https://github.com/popstas/server-scripts/blob/master/bin/average</a></p>

<p>Поставить можно так:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -s "https://raw.githubusercontent.com/popstas/server-scripts/master/bin/average" &gt; /usr/local/bin/average
</span><span class='line'>chmod +x /usr/local/bin/average</span></code></pre></td></tr></table></div></figure>


<p>Использовать можно так:</p>

<p>Запуск команды по умолчанию, 5 циклов:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>average 'command'</span></code></pre></td></tr></table></div></figure>


<p>Запуск команды с указанным кол-вом циклов:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>average 10 'command'</span></code></pre></td></tr></table></div></figure>


<p>Запуск команды с передачей кол-ва циклов через переменную окружения:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export CYCLES=5
</span><span class='line'>average 'command'</span></code></pre></td></tr></table></div></figure>


<p>Чтобы не показывать вывод команды, можно обрезать его через tail:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>average 'command' | tail -n1</span></code></pre></td></tr></table></div></figure>


<h3>Узнать среднее время загрузки страницы:</h3>

<p>С учетом кэша:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>average 'curl -s "http://example.com/" &gt; /dev/null'</span></code></pre></td></tr></table></div></figure>


<p>В обход кэша:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>average 'curl -s "http://example.com/?t=$RANDOM" &gt; /dev/null'</span></code></pre></td></tr></table></div></figure>


<hr />

<h3>Продвинутое использование</h3>

<p>Мне надо было узнать оптимальное количество параллельных процессов для запуска тестов,
теперь я могу узнать это запуском одной команды:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for p in {1..10}; do echo "$p" - $(average "vendor/bin/paratest -p $p" | tail -n1); done</span></code></pre></td></tr></table></div></figure>


<p>Команда переберет кол-во процессов от 1 до 10, по каждой итерации выведет среднее время.</p>

<p>После запуска получил такие результаты:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ for p in {1..10}; do echo "$p" - $(average "vendor/bin/paratest -p $p" | tail -n1); done
</span><span class='line'>
</span><span class='line'>1 - 1 loops, best of 5: 13.9 sec per loop
</span><span class='line'>2 - 1 loops, best of 5: 7.51 sec per loop
</span><span class='line'>3 - 1 loops, best of 5: 5.51 sec per loop
</span><span class='line'>4 - 1 loops, best of 5: 4.51 sec per loop
</span><span class='line'>5 - 1 loops, best of 5: 4.42 sec per loop
</span><span class='line'>6 - 1 loops, best of 5: 4.71 sec per loop
</span><span class='line'>7 - 1 loops, best of 5: 4.21 sec per loop
</span><span class='line'>8 - 1 loops, best of 5: 4.23 sec per loop
</span><span class='line'>9 - 1 loops, best of 5: 4.13 sec per loop
</span><span class='line'>10 - 1 loops, best of 5: 4.33 sec per loop</span></code></pre></td></tr></table></div></figure>


<p>Видно, что после 4 потоков разницы почти нет, а вот комп от запуска кучи параллельных процессов тормозит
очень даже заметно.</p>

<p>Конечно, в этом случае много ума не надо, чтобы понять, что кол-во процессов должно быть по кол-ву ядер, но я что-то засомневался :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Как я обрабатываю входящие потоки контента через RSS и Pocket или моя воронка статей]]></title>
    <link href="http://blog.popstas.ru/blog/2016/02/27/content-consumption-pyramid-rss/"/>
    <updated>2016-02-27T14:48:03+05:00</updated>
    <id>http://blog.popstas.ru/blog/2016/02/27/content-consumption-pyramid-rss</id>
    <content type="html"><![CDATA[<p>Хочу поделиться своим способом быть в курсе всего интересного в мире IT, читать много статей и знать, где быстро найти нужную статью.</p>

<p>Tl;dr: RSS + Twitter + Email &rarr; Pocket &rarr; Firefox &rarr; Twitter + закладки.</p>

<p><img src="http://blog.popstas.ru/images/2016-02/content_pyramid.png"></p>

<!-- more -->


<h1>Источники</h1>

<h2>RSS</h2>

<p>RSS - мой основной источник информации. Кто не пользовался RSS, не представляет, сколько всего можно получать через ленты:</p>

<ul>
<li>топ статей</li>
<li>статьи по конкретным категориям/тегам</li>
<li>комменты к редко обновляемым постам</li>
<li>вопросы/ответы по интересующим темам</li>
<li>личные блоги (вообще не представляю, как можно еще читать личные блоги)</li>
<li>подкасты</li>
<li>новые альбомы музыкальных групп</li>
</ul>


<p>Для сбора всех RSS в одном месте я использую Feedly, требований к нему у меня почти нет, когда умер Google Reader, перешел по первому результату, с тех пор пользуюсь.</p>

<p>99% RSS я читаю с телефона в дороге и на обедах.</p>

<p>Если по анонсу понятно, что статья полезная, я сразу пересылаю ее в Pocket и разгребаю RSS дальше.</p>

<p>На Android использую gReader, он глючный, кто знает нормальный RSS клиент - скажите.</p>

<h2>Email</h2>

<p>Email рассылки не умерли, как наверное многие думают. Лично я считаю, что их легко могла бы заменить RSS лента с тем же контентом, но она почему-то есть не у всех, видимо потому, что email проще.</p>

<p>Написав это, я подумал: &ldquo;А ведь должен быть шлюз Email-RSS!&rdquo; Так и оказалось, первый результат привел меня на бесплатный сервис <a href="https://emails2rss.appspot.com">emails2rss.appspot.com</a>, собранный на коленке, который по авторизации через Google дает вам виртуальный email, на который надо оформлять подписки и настоящую RSS ленту. Так вот при написании статьи я немного изменил свои источники контента :) Тут есть небольшой риск потерять часть своих лент из-за смерти сервиса, но рассылки еженедельные, так что думаю я это замечу.</p>

<p>Чтобы не валить все в одну кучу, можно создать несколько виртуальных email и RSS.</p>

<p>Шлюз это конечно хорошо, но есть также источники email рассылок, которые завернуть будет сложнее: те, где вы регаетесь под своим email. Это тоже решаемо: создаем фильтр в почтовом клиенте, который будет пересылать письма. Думаю, что через пару недель я перестану получать новостные рассылки в почту.</p>

<h2>Подкасты</h2>

<p>Подкасты я открыл для себя чуть больше года назад и быстро пожалел&hellip; что так долго ими не пользовался!
У подкастов своя ниша: их можно читать, когда ты занят чем-то физически, а голова свободна:</p>

<ul>
<li>на улице пешком, на велике или лыжах</li>
<li>во время ремонта, копания в огороде</li>
<li>во время уборки, мытья посуды, домашних дел</li>
<li>во время бездумных действий за компом (тренировка слепой печати, чистка мусора на диске)</li>
</ul>


<p>Подкасты у меня в голове делятся на 2 типа: развлекательные и полезные. Конечно, в каждом есть и то, и другое, но в целом разграничение достаточно четкое.</p>

<p>У любого нормального подкаста (да у всех) есть RSS. Тут есть один момент: формат RSS подкаста отличается от обычного, там должна быть специально размеченная ссылка на mp3, я долго не придавал этому значения, из-за чего подписывался на RSS <strong>сайта</strong> подкаста, а не сам подкаст. Это лишает вас возможности автоматически скачивать их (об этом ниже, в части про плеер). Так что вам нужно искать именно ссылку на подкаст, она часто называется ссылка на iTunes, я ее боялся и не переходил туда, оказалось, что по ссылке лежит RSS.</p>

<p>У подкастов обычно есть &ldquo;шоуноты&rdquo;, текстовое краткое содержание и список ссылок, которые обсуждали, их тоже бывает полезно смотреть, но я забываю.</p>

<p>На подкасты я подсел через <a href="https://radio-t.com/">Радио Т</a>, какое-то время слушал только их, пока не переслушал все, что было интересного. А потом как началось&hellip; Я примерно 2 месяца тренировал слепую печать по часу в день, и чтобы совместить полезное с полезным, параллельно слушал подкасты. В таком темпе они очень быстро кончились и пришлось искать новые.</p>

<p>Подкастов, в отличие от RSS, сравнительно немного и выбор небольшой, поэтому их еще надо найти. <a href="https://gpodder.net/user/popstas/subscriptions">Здесь</a> лежит мой список, а на <a href="https://github.com/AveVlad/russia-it-podcast">AveVlad/russia-it-podcast</a> самый большой список русских подкастов, его можно дополнять, я туда заношу новое, что нахожу.</p>

<h2>Видеоматериалы</h2>

<p>Видеоматериалы попадаются единичные и в виде курсов. Разницы в общем нет, а рассказать надо о том, что сразу не приходит в голову: большую часть выступлений можно не смотреть, а только слушать! И да, для этого есть <a href="http://www.onlinevideoconverter.com/video-converter">сервис</a>, за полминуты получаем mp3 с видео, дальше все как с подкастами.</p>

<p>Просто так втыкать в видео мне редко хочется, у таких видяшек два сценария:</p>

<ul>
<li>во время бездумных действий за компом</li>
<li>во время ужина, вместо сериалов</li>
</ul>


<h2>Twitter</h2>

<p>Чтобы нормально использовать твиттер в режиме чтения, вам нужно отписаться ото всех, кто генерирует спам и оставить только тех, кто твиттит интересное вам. Казалось бы, очевидная вещь, но я это сразу не понял, начал подписываться на все подряд, дублируя функционал RSS, быстро засорил ленту и на несколько лет забыл о твиттере.</p>

<p>Сейчас я тоже не скажу, чтобы я много инфы оттуда доставал, но случается. Проблема в том, что найти интересных вам генераторов сложно, я этим специально не занимался, поэтому у меня интересный генератор один, и я и так подписан на его блог.</p>

<h1>Посредники</h1>

<h2>Pocket</h2>

<p>Главный агрегатор нефильтрованного контента, ставится на телефон и в браузеры, позволяет в один клик добавить статью в список на прочтение. На телефоне статьи доступны оффлайн.</p>

<p>Сюда попадает все:</p>

<ul>
<li>RSS</li>
<li>любые интересные найденные материалы</li>
</ul>


<p>Это помогает найти статью, даже если она не пойдет дальше, а также точнее следить за количиеством прочитанных статей (люблю я все считать, да :)</p>

<p>В Pocket прочитывается большинство статей, но некоторые уходят на прочтение в мобильный браузер (Pocket иногда портит оформление статьи), в Reedy или на домашний комп.</p>

<h2>Браузер</h2>

<p>В Firefox есть удобная штука: пересылка вкладки с одного устройства на другое, объединенных одним аккаунтом синхронизации. Поэтому все, что на телефоне читать неудобно, сразу улетает на домашний комп. Для хрома тоже вроде есть что-то подобное.</p>

<h2>Плеер</h2>

<p>В плеере лежат подкасты и записи с конференций. Под плеером я имею в виду телефон, и тут надо рассказать о том, как подкасты попадают туда. В двух словах: качалка подкастов + синхронизация файлов.</p>

<p>Я использую gPodder для скачивания подкастов. Раньше, когда сидел на Ubuntu, пользовался местным плеером Rhytmbox для этого, у gPodder плюсы в том, что он есть под все операционки и он дает аккаунт, где собраны все ваши подкасты.</p>

<p>Пользоваться так: создаем аккаунт (не обязательно), задаем папку для сохранения или iPod, добавляем RSS подкастов (в части про подкасты написано, чем они отличаются от обычных RSS) после этого подкасты будут прилетать сами, вам остается по Ctrl+S переслать их в плеер.</p>

<p>Если у вас не iPod, то тут есть 2 варианта: использовать синхронизацию файлов (я раньше использовал BTSync, потом перешел на Syncthing) или, если у вас Android, поставить gPodder прямо на него. Мне больше нравится синхронизация через комп, так как я бывает не успеваю слушать все подкасты, а они все прибывают, в итоге место на телефоне кончается.</p>

<p>Для прослушивания использую <a href="https://play.google.com/store/apps/details?id=ak.alizandro.smartaudiobookplayer&amp;hl=ru">Smart AudioBook Player</a>.</p>

<h2>Reedy</h2>

<p>Из Pocket некоторые статьи читаются через <a href="https://habrahabr.ru/post/220775/">Reedy</a>, использую редко, но он мне нравится, это такая программа для скорочтения: слова бегут по экрану, наподобие бегущей строки, так и читаете. Звучит неубедительно, это надо попробовать, у меня таким способам статьи читаются в 1.5-2 раза быстрее.</p>

<p>Минус в том, что мало что можно так прочитать: статья должна быть без картинок, кода, формул, таблиц - только текст, иначе ничего не понятно будет.</p>

<h1>Хранители</h1>

<p>Судьба лучших материалов - попасть на долгое хранение.</p>

<h2>Twitter</h2>

<p>Каждую прочитанную статью, которая понравилась, я в последнее время отправляю в твиттер, таким образом я создал для себя самую узкую часть моей воронки контентопотребления. Не знаю зачем, но думаю, пригодится может кто-то будет меня читать, а если нет, может мне понадобятся все эти статьи, тогда я смогу их оттуда достать.</p>

<h2>Закладки</h2>

<p>Статьи, которые пригодятся потом, я отправляю в браузер, а приходя домой, добавляю их в закладки, проставляю теги. Это очень помогает находить контент, который уже прочитал, но был еще не в теме. Например, вникаю в тестирование и все, что может быть полезным, скидываю в закладки, потом проще искать, когда понадобится.</p>

<p>Самое главное не забыть сначала поискать в закладках нужную тему перед тем как гуглить.</p>

<h1>Источники для отдыха</h1>

<h2>Вконтакте</h2>

<p>Ленту вконтакте за день можно читать за 1-2 минуты, рецепт тот же, что и для твиттера: отпишитесь от спамогенераторов и от пабликов (1-2 пишущих по 3 раза в день можно и оставить). Удалять из друзей не обязательно, можно просто не показывать записи в ленте. Тут вроде работает правило 20/80, так что много отписывать не надо будет.</p>

<h2>Музыка</h2>

<p>Давно хотел сразу узнавать, если у групп, которые я слушаю, появляются новые альбомы. Так вот, теперь это возможно! Я использую комбинацию RSS для групп, которые не спамят + подписка на исполнителя в яндекс музыке для всех групп. Это работает уже пару лет, стоит один раз потратить вечер на добавление исполнителей из вашего плейлиста в подписки и вы будете получать обновления по ним.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker в картинках]]></title>
    <link href="http://blog.popstas.ru/blog/2016/02/26/docker-in-images/"/>
    <updated>2016-02-26T21:29:45+05:00</updated>
    <id>http://blog.popstas.ru/blog/2016/02/26/docker-in-images</id>
    <content type="html"><![CDATA[<p>Оставлю здесь <a href="http://habrahabr.ru/post/272145/">свой пост</a> с хабра.</p>

<p><em>Перевод поста <a href="http://merrigrove.blogspot.co.uk/2015/10/visualizing-docker-containers-and-images.html">Visualizing Docker Containers and Images</a>, от новичка к новичкам, автор на простых примерах объясняет базовые сущности и процессы в использовании docker.</em></p>

<p>Если вы не знаете, что такое Docker или не понимаете, как он соотносится с виртуальными машинами или с инструментами configuration management, то этот пост может показаться немного сложным.</p>

<p>Пост предназначен для тех, кто пытается освоить docker cli, понять, чем отличается контейнер и образ. В частности, будет объяснена разница между просто контейнером и запущенным контейнером.
<img src="https://habrastorage.org/files/8ff/349/fb2/8ff349fb23f840589c479d029964b8dc.png"></p>

<!-- more -->


<p>В процессе освоения нужно представить себе некоторые лежащие в основе детали, например, слои файловой системы UnionFS. В течение последней пары недель я изучал технологию, я новичок в мире docker, и командная строка docker показалась мне довольно сложной для освоения.</p>

<p>По-моему, понимание того, как технология работает изнутри - лучший способ быстро освоить новый инструмент и правильно его использовать. Часто новая технология разрабатывает новые модели абстракций и привносит новые термины и метафоры, которые могут быть как будто бы понятны в начале, но без четкого понимания затрудняют последующее использование инструмента.</p>

<p>Хорошим примером является Git. Я не мог понять Git, пока не понял его базовую модель, включая trees, blobs, commits, tags, tree-ish и прочее. Я думаю, что люди, не понимающие внутренности Git, не могут мастерски использовать этот инструмент.</p>

<h2>Определение образа (Image)</h2>

<p>Визуализация образа представлена ниже в двух видах. Образ можно определить как &ldquo;сущность&rdquo; или &ldquo;общий вид&rdquo; (union view) стека слоев только для чтения.</p>

<p><img src="https://habrastorage.org/files/243/a01/1ed/243a011ed04f455099a4ba64a87736f6.png"></p>

<p>Слева мы видим стек слоев для чтения. Они показаны только для понимания внутреннего устройства, они доступны вне запущенного контейнера на хост-системе. Важно то, что они доступны только для чтения (иммутабельны), а все изменения происходят в верхнем слое стека. Каждый слой может иметь одного родителя, родитель тоже имеет родителя и т.д. Слой верхнего уровня может быть использован как UnionFS (AUFS в моем случае с docker) и представлен в виде единой read-only файловой системы, в которой отражены все слои. Мы видим эту &ldquo;сущность&rdquo; образа на рисунке справа.</p>

<p>Если вы захотите посмотреть на эти слои в первозданном виде, вы можете найти их в файловой системе на хост-машине. Они не видны напрямую из запущенного контейнера. На моей хост-машине я могу найти образы в /var/lib/docker/aufs.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># sudo tree -L 1 /var/lib/docker/
</span><span class='line'>/var/lib/docker/
</span><span class='line'>├── aufs
</span><span class='line'>├── containers
</span><span class='line'>├── graph
</span><span class='line'>├── init
</span><span class='line'>├── linkgraph.db
</span><span class='line'>├── repositories-aufs
</span><span class='line'>├── tmp
</span><span class='line'>├── trust
</span><span class='line'>└── volumes
</span><span class='line'>
</span><span class='line'>7 directories, 2 files</span></code></pre></td></tr></table></div></figure>


<h2>Определение контейнера (Container)</h2>

<p>Контейнер можно назвать &ldquo;сущностью&rdquo; стека слоев с верхним слоем для записи.</p>

<p><img src="https://habrastorage.org/files/8d3/d29/494/8d3d29494dbf46f79b1be15cea7516c4.png"></p>

<p>На изображении выше показано примерно то же самое, что на изображении про образ, кроме того, что верхний слой доступен для записи. Вы могли заметить, что это определение ничего не говорит о том, запущен контейнер или нет и это неспроста. Разделение контейнеров на запущенные и не запущенные устранило путаницу в моем понимании.</p>

<p>Контейнер определяет лишь слой для записи наверху образа (стека слоев для чтения). Он не запущен.</p>

<h2>Определение запущенного контейнера</h2>

<p>Запущенный контейнер - это &ldquo;общий вид&rdquo; контейнера для чтения-записи и его изолированного пространства процессов. Ниже изображен контейнер в своем пространстве процессов.</p>

<p><img src="https://habrastorage.org/files/c72/5d3/b0b/c725d3b0be5742aca5f50310d640d0b1.png"></p>

<p>Изоляция файловой системы обеспечивается технологиями уровня ядра, cgroups, namespaces и другие, позволяют докеру быть такой перспективной технологией. Процессы в пространстве контейнера могут изменять, удалять или создавать файлы, которые сохраняются в верхнем слое для записи. Смотрите изображение:</p>

<p><img src="https://habrastorage.org/files/f8e/bbf/e3b/f8ebbfe3b59346ee9cdb017b89fcb169.png"></p>

<p>Чтобы проверить это, выполните команду на хост-машине:</p>

<p><source lang="bash">
docker run ubuntu touch happiness.txt
</source>
Вы можете найти новый файл в слое для записи на хост-машине, даже если контейнер не запущен.</p>

<p><source lang="bash"></p>

<h1>find / -name happiness.txt</h1>

<p>/var/lib/docker/aufs/diff/860a7b&hellip;889/happiness.txt
</source></p>

<h2>Определение слоя образа (Image layer)</h2>

<p>Наконец, мы определим слой образа. Изображение ниже представляет слой образа и дает нам понять, что слой - это не просто изменения в файловой системе.</p>

<p><img src="https://habrastorage.org/files/928/23a/1a0/92823a1a03ad487586293f37e78cf74f.png"></p>

<p>Метаданные - дополнительная информация о слое, которая позволяет докеру сохранять информацию во время выполнения и во время сборки. Оба вида слоев (для чтения и для записи) содержат метаданные.</p>

<p><img src="https://habrastorage.org/files/b7e/d04/252/b7ed042525f647b986009b82d18b3fee.png"></p>

<p>Кроме того, как мы уже упоминали раньше, каждый слой содержит указатель на родителя, используя id (на изображении родительские слои внизу). Если слой не указывает на родительский слой, значит он наверху стека.</p>

<p><img src="https://habrastorage.org/files/7e9/de2/c4f/7e9de2c4f537438c8f5357d09c398289.png"></p>

<h5>Расположение метаданных</h5>


<p>На данный момент (я понимаю, что разработчики docker могут позже сменить реализацию), метаданные слоев образов (для чтения) находятся в файле с именем &ldquo;json&rdquo; в папке /var/lib/docker/graph/id_слоя:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/var/lib/docker/graph/e809f156dc985.../json</span></code></pre></td></tr></table></div></figure>


<p>где &ldquo;e809f156dc985&hellip;&rdquo; - урезанный id слоя.</p>

<h2>Свяжем все вместе</h2>

<p>Теперь, давайте посмотрим на команды, иллюстрированные понятными картинками.</p>

<h3>docker create <image-id></h3>

<p>До:
<img src="https://habrastorage.org/files/71a/d30/a1e/71ad30a1e0b04cb09db3e25c741ef7a8.png"></p>

<p>После:
<img src="https://habrastorage.org/files/bdc/1cc/f14/bdc1ccf14b1c4702afe71cbd27a1574b.png"></p>

<p>Команда &lsquo;docker create&rsquo; добавляет слой для записи наверх стека слоев, найденного по <image-id>. Команда не запускает контейнер.</p>

<p><img src="https://habrastorage.org/files/12c/8d5/606/12c8d56068c5416e8ca003b532ef3cdb.png"></p>

<h3>docker start <container-id></h3>

<p>До:
<img src="https://habrastorage.org/files/bdc/1cc/f14/bdc1ccf14b1c4702afe71cbd27a1574b.png"></p>

<p>После:
<img src="https://habrastorage.org/files/730/6c4/4cd/7306c44cdfdd4ead9f1f073d91dd312c.png"></p>

<p>Команда &lsquo;docker start&rsquo; создает пространство процессов вокруг слоев контейнера. Может быть только одно пространство процессов на один контейнер.</p>

<h3>docker run <image-id></h3>

<p>До:
<img src="https://habrastorage.org/files/71a/d30/a1e/71ad30a1e0b04cb09db3e25c741ef7a8.png"></p>

<p>После:
<img src="https://habrastorage.org/files/730/6c4/4cd/7306c44cdfdd4ead9f1f073d91dd312c.png"></p>

<p>Один из первых вопросов, который задают люди (я тоже задавал): &ldquo;В чем разница между &lsquo;docker start&rsquo; и &lsquo;docker run&rsquo;?&rdquo; Одна из первоначальных целей этого поста - объяснить эту тонкость.</p>

<p><img src="https://habrastorage.org/files/429/f39/fc6/429f39fc67d44579a40365018dc6839e.png"></p>

<p>Как мы видим, команда &lsquo;docker run&rsquo; находит образ, создает контейнер поверх него и запускает контейнер. Это сделано для удобства и скрывает детали двух команд.</p>

<p>Продолжая сравнение с освоением Git, я скажу, что &lsquo;docker run&rsquo; очень похожа на &lsquo;git pull&rsquo;. Так же, как и &lsquo;git pull&rsquo; (который объединяет &lsquo;git fetch&rsquo; и &lsquo;git merge&rsquo;), команда &lsquo;docker run&rsquo; объединяет две команды, которые могут использоваться и независимо. Это удобно, но поначалу может ввести в заблуждение.</p>

<h3>docker ps</h3>

<p><img src="https://habrastorage.org/files/441/0ed/8b7/4410ed8b7bb94de68dfae60a79a08aca.png"></p>

<p>Команда &lsquo;docker ps&rsquo; выводит список запущенных контейнеров на вашей хост-машине. Важно понимать, что в этот список входят только запущенные контейнеры, не запущенные контейнеры скрыты. Чтобы посмотреть список всех контейнеров, нужно использовать следующую команду.</p>

<h3>docker ps -a</h3>

<p><img src="https://habrastorage.org/files/633/55a/c1a/63355ac1a27d4cf6a1f10142cc89d7b0.png"></p>

<p>Команда &lsquo;docker ps -a&rsquo;, где &lsquo;a&rsquo; - сокращение от &lsquo;all&rsquo; выводит список всех контейнеров, независимо от их состояния.</p>

<h3>docker images</h3>

<p><img src="https://habrastorage.org/files/2d2/29e/bc6/2d229ebc667244b3b478298aa3162c7e.png"></p>

<p>Команда &lsquo;docker images&rsquo; выводит список образов верхнего уровня (top-level images). Фактически, ничего особенного не отличает образ от слоя для чтения. Только те образы, которые имеют присоединенные контейнеры или те, что были получены с помощью pull, считаются образами верхнего уровня. Это различие нужно для удобства, так как за каждым образом верхнего уровня может быть множество слоев.</p>

<h3>docker images -a</h3>

<p><img src="https://habrastorage.org/files/5b6/6a9/fd9/5b66a9fd93ce4157b3cfa48984a5ca0d.png"></p>

<p>Команда &lsquo;docker images -a&rsquo; выводит все образы на хост-машине. Это фактически список всех слоев для чтения в системе. Если вы хотите увидеть все слои одного образа, воспользуйтесь командой &lsquo;docker history&rsquo;.</p>

<h3>docker stop <container-id></h3>

<p>До:
<img src="https://habrastorage.org/files/f34/430/e32/f34430e3231842e3b748d337993e9338.png"></p>

<p>После:
<img src="https://habrastorage.org/files/bdc/1cc/f14/bdc1ccf14b1c4702afe71cbd27a1574b.png"></p>

<p>Команда &lsquo;docker stop&rsquo; посылает сигнал SIGTERM запущенному контейнеру, что мягко останавливает все процессы в пространстве процессов контейнера. В результате мы получаем не запущенный контейнер.</p>

<h3>docker kill <container-id></h3>

<p>До:
<img src="https://habrastorage.org/files/ef8/c77/3c3/ef8c773c34454292b76f798482e15463.png"></p>

<p>После:
<img src="https://habrastorage.org/files/bdc/1cc/f14/bdc1ccf14b1c4702afe71cbd27a1574b.png"></p>

<p>Команда &lsquo;docker kill&rsquo; посылает сигнал SIGKILL, что немедленно завершает все процессы в текущем контейнере. Это почти то же самое, что нажать Ctrl+\ в терминале.</p>

<h3>docker pause <container-id></h3>

<p>До:
<img src="https://habrastorage.org/files/63d/de7/ed4/63dde7ed482544e0afcc2925eabc1e3d.png"></p>

<p>После:
<img src="https://habrastorage.org/files/70d/208/439/70d208439a1944739c5e06e716ab1975.png"></p>

<p>В отличие от &lsquo;docker stop&rsquo; и &lsquo;docker kill&rsquo;, которые посылают настоящие UNIX сигналы процессам контейнера, команда &lsquo;docker pause&rsquo; используют специальную возможность cgroups для заморозки запущенного пространства процессов. Подробности можно прочитать <a href="https://www.kernel.org/doc/Documentation/cgroups/freezer-subsystem.txt">здесь</a>, если вкратце, отправки сигнала Ctrl+Z (SIGTSTP) не достаточно, чтобы заморозить все процессы в пространстве контейнера.</p>

<h3>docker rm <container-id></h3>

<p>До:
<img src="https://habrastorage.org/files/92d/14d/d92/92d14dd9224043079a90ab80c4dbc6a6.png"></p>

<p>После:
<img src="https://habrastorage.org/files/a36/292/8c4/a362928c4661422797d267560ff38182.png"></p>

<p>Команда &lsquo;docker rm&rsquo; удаляет слой для записи, который определяет контейнер на хост-системе. Должна быть запущена на остановленном контейнерах. Удаляет файлы.</p>

<h3>docker rmi <image-id></h3>

<p>До:
<img src="https://habrastorage.org/files/4c2/eb5/26a/4c2eb526a35e4751a5302c954370a0fa.png"></p>

<p>После:
<img src="https://habrastorage.org/files/3a2/145/38a/3a214538a6e54e009f704825109393a1.png"></p>

<p>Команда &lsquo;docker rmi&rsquo; удаляет слой для чтения, который определяет &ldquo;сущность&rdquo; образа. Она удаляет образ с хост-системы, но образ все еще может быть получен из репозитория через &lsquo;docker pull&rsquo;. Вы можете использовать &lsquo;docker rmi&rsquo; только для слоев верхнего уровня (или образов), для удаления промежуточных слоев нужно использовать &lsquo;docker rmi -f&rsquo;.</p>

<h3>docker commit <container-id></h3>

<p>До:
<img src="https://habrastorage.org/files/7d0/ec4/104/7d0ec41049b34238bb785e28897e28f0.png"> или <img src="https://habrastorage.org/files/325/e8e/270/325e8e27098e4cdeb956634361879388.png"></p>

<p>После:
<img src="https://habrastorage.org/files/daa/69c/50f/daa69c50fbc3479ba9d6497983b73a02.png"></p>

<p>Команда &lsquo;docker commit&rsquo; берет верхний уровень контейнера, тот, что для записи и превращает его в слой для чтения. Это фактически превращает контейнер (вне зависимости от того, запущен ли он) в неизменяемый образ.</p>

<p><img src="https://habrastorage.org/files/e3d/7d7/766/e3d7d7766165425a9148ac61369ffe9c.png"></p>

<h3>docker build</h3>

<p>До:
Dockerfile <img src="https://habrastorage.org/files/847/71b/87a/84771b87a8cd4d77b63d39a3ae9dae13.png"> и <img src="https://habrastorage.org/files/71a/d30/a1e/71ad30a1e0b04cb09db3e25c741ef7a8.png"></p>

<p>После:
<img src="https://habrastorage.org/files/71a/d30/a1e/71ad30a1e0b04cb09db3e25c741ef7a8.png">
Со многими другими слоями.</p>

<p>Команда &lsquo;docker build&rsquo; интересна тем, что запускает целый ряд команд:
<img src="https://habrastorage.org/files/b25/36e/cac/b2536ecac84148ba9a043bb00fe3ce5a.png"></p>

<p>На изображении выше мы видим, как команда build использует значение инструкции FROM из файла Dockerfile как базовый образ после чего:</p>

<p>1) запускает контейнер (create и start)
2) изменяет слой для записи
3) делает commit
На каждой итерации создается новый слой. При исполнении &lsquo;docker build&rsquo; может создаваться множество слоев.</p>

<h3>docker exec <running-container-id></h3>

<p>До:
<img src="https://habrastorage.org/files/7d0/ec4/104/7d0ec41049b34238bb785e28897e28f0.png"></p>

<p>После:
<img src="https://habrastorage.org/files/4d6/cd5/21e/4d6cd521ee4d47e68d89e9ce77c8a6ca.png"></p>

<p>Команда &lsquo;docker exec&rsquo; применяется к запущенному контейнеру, запускает новый процесс внутри пространства процессов контейнера.</p>

<h3>docker inspect <container-id> | <image-id></h3>

<p>До:
<img src="https://habrastorage.org/files/74c/7ee/e53/74c7eee53b8f4ed8a2a606e87571fe3a.png"> или <img src="https://habrastorage.org/files/242/b58/b68/242b58b68acd4580b226569d81d613e5.png"></p>

<p>После:
<img src="https://habrastorage.org/files/898/5e8/e54/8985e8e5467a42769988a4351d0c0828.png"></p>

<p>Команда &lsquo;docker inspect&rsquo; получает метаданные верхнего слоя контейнера или образа.</p>

<h3>docker save <image-id></h3>

<p>До:
<img src="https://habrastorage.org/files/f2a/b8d/70d/f2ab8d70de7a4ca4959f6a7bf1fb11e3.png"></p>

<p>После:
<img src="https://habrastorage.org/files/d5d/bf7/3f0/d5dbf73f0f2d4d72b0ed38309e2c6a6b.png"></p>

<p>Команда &lsquo;docker save&rsquo; создает один файл, который может быть использован для импорта образа на другую хост-систему. В отличие от команды &lsquo;export&rsquo;, она сохраняет все слои и их метаданные. Может быть применена только к образам.</p>

<h3>docker export <container-id></h3>

<p>До:
<img src="https://habrastorage.org/files/a7f/3f4/717/a7f3f47170084dc2b75dd73e8d6a5cbb.png"></p>

<p>После:
<img src="https://habrastorage.org/files/36d/807/ed6/36d807ed6b304333b31f658dfb5c4326.png"></p>

<p>Команда &lsquo;docker export&rsquo; создает tar архив с содержимым файлов контейнера, в результате получается папка, пригодная для использования вне docker. Команда убирает слои и их метаданные. Может быть применена только для контейнеров.</p>

<h3>docker history <image-id></h3>

<p>До:
<img src="https://habrastorage.org/files/428/150/afc/428150afc2574fd2bf32f1202c908f77.png"></p>

<p>После:
<img src="https://habrastorage.org/files/e82/45f/511/e8245f51120340b19e07c6009f2d4ce8.png"></p>

<p>Команда &lsquo;docker history&rsquo; принимает <image-id> и рекурсивно выводит список всех слоев-родителей образа (которые тоже могут быть образами)</p>

<h2>Итог</h2>

<p>Я надеюсь, вам понравилась эта визуализация контейнеров и образов. Есть много других команд (pull, search, restart, attach и другие), которые могут или не могут быть объяснены моими сравнениями.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Большой тачпад как замена мышки]]></title>
    <link href="http://blog.popstas.ru/blog/2016/02/25/big-touchpad-as-mouse-replacement/"/>
    <updated>2016-02-25T23:31:57+05:00</updated>
    <id>http://blog.popstas.ru/blog/2016/02/25/big-touchpad-as-mouse-replacement</id>
    <content type="html"><![CDATA[<p>Наслушавшись рассказов про то, какой на макбуке офигенный большой тачпад и как он легко заменяет мышку,
нашел способ испытать это на себе бесплатно. Описываю свои впечатления как обычно: плюсы, минусы, грабли, способы обхода.</p>

<p><img src="http://blog.popstas.ru/images/2016-02/touchpad_wacom.jpg"></p>

<!-- more -->


<p>Мне повезло: у нас в офисе лежал без дела графический планшет Wacom Intuos Pen &amp; Touch Medium.
Выглядит как огромный (почти А4 формата) тачпад, экрана нет, зато есть поддержка всех операционок и мультитач.</p>

<p>Не скажу насчет винды и линукса, расскажу про мак, но уверен, что по поддержке жестов в Windows не отстает, по крайней мере у Wacom драйвера примерно одинаковые везде.</p>

<h1>Плюсы:</h1>

<ol>
<li><p>Скролл как на мобиле! Можно прокрутить 1000 строк и страницу любой длины за секунду, с таким же кинетическим эффектом, как на мобильном. То есть можно махнуть плавно и прокрутить чуть-чуть, а можно резко. У меня на работе мышка Logitech M705, у нее колесико не зафиксировано, ей можно делать то же самое, а вот дома такого не хватало.</p></li>
<li><p>Больше действий, чем на мышке. Мышки у меня были разные, бывало от 2 до 8 кнопок, последние лет 8 использую мышки с кнопками вперед-назад. У тачпада возможности намного больше.</p></li>
<li><p>Жесты. Если кто-то пробовал использовать жесты мышью в опере или с помощью утилит, то на тачпаде то же самое, но лучше. У меня на wacom доступны простые жесты, я не нашел софт под него, чтобы настроить свои, но даже при этом мне нравится: можно использовать от 1 до 4 пальцев, у каждого сочетания своя функция, в итоге передвигая пальцы вправо, можно вести курсор, выделять текст, переходить вперед в браузере, перетаскивать что-то или переключать текущее окно, в зависимости от сочетания. Ну и местами зум, поворот (ни разу не использовал).</p></li>
<li><p>Горизонтальный скролл теперь так же прост, как вертикальный. Это я не сразу понял, а когда открыл браузер на треть экрана и понял, что дотянуться до кнопки в правой части экрана за пределами видимости очень просто. По сути это для меня в некоторых случаях расширяет рабочую область экрана, которой много не бывает.</p></li>
<li><p>Плюс, растущий из минуса: в ситуациях, где мышкой было бы удобнее, руки тянутся к клавиатуре, надеюсь, они там найдут способы делать что надо быстрее, чем мышкой. Этого можно достичь и менее радикальными способами, но <a href="https://www.youtube.com/watch?v=NnTi9B-D6LA">по бразильской системе</a> все быстрее осваивается :) В PhpStorm уже почувствовал прогресс в клавиатурном управлении, хотя к этому причастен еще и <a href="https://www.youtube.com/watch?v=eq3KiAH4IBI">мастер-класс по Idea</a></p></li>
<li><p>Рука меньше устает. Запястье не упирается в стол на изгибе, а лежит на нем. Тачпадом, в отличие от мышки, можно точно управлять одними пальцами, поэтому запястье либо не касается стола, либо касается, но не играет роли опорной точки.</p></li>
<li><p>Можно тестить поведение сайтов на телефоне. Надуманный плюс, я это не использовал и может никогда не использую.</p></li>
</ol>


<h1>Минусы:</h1>

<ol>
<li><p>Неудобно перетаскивать. Выделение области скриншота, перетаскивание файлов - совершая подобные действия, вы рискуете не дотянуть докуда надо, так как нельзя в отличие от мышки, удерживая кнопку, передвинуть мышку и дотащить элемент.</p></li>
<li><p>Неудобно выделять. Все-таки точность у мыши намного выше, я за 2 дня научился точно попадать тачпадом между букв, куда мне надо, но чувствуется, что мышкой быстрее.</p></li>
<li><p>Мало жестов. Стандартный драйвер поддерживает 95% жестов из справки к системе и больше ничего. Нестандартного я не нашел.</p></li>
<li><p>Не хватает колесика от мышки. Постоянно его использую и без него обламываюсь. Открываю ссылки в новой вкладке через контекстное меню, закрываю вкладки крестиком&hellip; это конечно шаг назад.</p></li>
<li><p>Пальцы иногда срываются. Случайно нажать или отпустить палец в неподходящий момент намного проще, чем мышкой, из-за этого бывают случайные срабатывания всякой фигни.</p></li>
<li><p>Чувствительность может потеряться из-за состояния ваших пальцев. Не знаю, как эппловский тачпад, а вакомовский плохо понимает слишком потные, слишком сухие, слишком пыльные пальцы. А если один палец более скользкий, чем другой (такое случается), скроллить страницу двумя пальцами становится не так удобно. С мышкой таких проблем нет.</p></li>
<li><p>Большой. Мышь занимает меньше места даже с учетом ее рабочей площади. По ощущениям могу сказать, что толку от такого огромного тачпада немного, проявляется только когда нужно что-то перетащить на большое расстояние.</p></li>
</ol>


<h1>Решение проблем</h1>

<ol>
<li><p>Кастомные жесты. На маке похоже решаются только покупкой эппловского тачпада, на который есть миллион программ для расширения функциональности.</p></li>
<li><p>Перетаскивание. Решается эппловским тачпадом.</p></li>
<li><p>Колесико тоже надеюсь заменить кастомным жестом.</p></li>
<li><p>С пальцами ничего не сделаешь, уж какие есть, нерешаемая проблема.</p></li>
</ol>


<h1>Выводы</h1>

<p>Тачпадом вместо мышки я пользуюсь около месяца, руки к мышке уже не тянутся, но она лежит рядом, на всякие случаи, которые бывали раза два за месяц.</p>

<p>Как это ни странно (мне странно), думаю, что тачпад может быть удобнее мышки. Когда куплю нормальный тачпад, узнаю, так ли это.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Проверяем изменения на странице через Cron]]></title>
    <link href="http://blog.popstas.ru/blog/2016/01/31/check-webpage-changes-with-cron/"/>
    <updated>2016-01-31T02:00:13+05:00</updated>
    <id>http://blog.popstas.ru/blog/2016/01/31/check-webpage-changes-with-cron</id>
    <content type="html"><![CDATA[<p>Сегодня хотел заказать ароматизаторов на <a href="http://baker-flavors.blogspot.ru/">Baker Flavours</a>, дошел до страницы заказа,
и увидел &ldquo;Уважаемые заказчики! В связи с чрезвычайно большим количеством заказов, прием заказов временно прекращен.&rdquo;.</p>

<p>Ок, будем ждать, пока эта надпись не пропадет, а чтобы не проверять руками, будем делать это на автомате и ждать уведомления.</p>

<p>Строчка для crontab:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>0 20 * * * curl -s http://bakerflavors.ru/formbf.htm | iconv -f windows-1251 -t utf-8 | grep "временно прекращен" &gt; /dev/null || { echo "BF order started" | terminal-notifier && open http://bakerflavors.ru/formbf.htm }</span></code></pre></td></tr></table></div></figure>


<p>Подробности под катом.</p>

<!-- more -->


<p>Нужно сделать так, чтобы я узнал о том, что этот текст со страницы пропадет.</p>

<p>Получаем содержимое страницы:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -s http://bakerflavors.ru/formbf.htm</span></code></pre></td></tr></table></div></figure>


<p>Оказалось, что страница в windows-1251 кодировке и выдает <code>�</code>. Конвертируем:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -s http://bakerflavors.ru/formbf.htm | iconv -f windows-1251 -t utf-8</span></code></pre></td></tr></table></div></figure>


<p>Проверяем наличие текста:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -s http://bakerflavors.ru/formbf.htm | iconv -f windows-1251 -t utf-8 | grep "временно прекращен" &gt; /dev/null </span></code></pre></td></tr></table></div></figure>


<p>Когда текст пропадет, grep выдаст ненулевой exitcode. Добавляем действие на этот случай.</p>

<p>В начале я сделал как обычно делаю на сервере: отправил письмо через команду <code>mail</code>. Оказалось, что письмо уходит в спам.
Не стал с этим разбираться, вместо этого буду показывать notification. Уведомление сделал через
<a href="https://github.com/julienXX/terminal-notifier">julienXX/terminal-notifier</a> (Mac OS),
но тут опять вышел облом: уведомление нельзя показывать бесконечно, если я окажусь в это время не перед экраном,
я об этом не узнаю. Поэтому буду еще и открывать страницу заказа в браузере. В итоге получилось вот это:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -s http://bakerflavors.ru/formbf.htm | iconv -f windows-1251 -t utf-8 | grep "временно прекращен" &gt; /dev/null || { \
</span><span class='line'>  echo "BF order started" | terminal-notifier && \
</span><span class='line'>  open http://bakerflavors.ru/formbf.htm \
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[E.ggtimer: таймер в пару кликов в любом браузере]]></title>
    <link href="http://blog.popstas.ru/blog/2016/01/31/timer-in-browser-with-1-second-time-to-start/"/>
    <updated>2016-01-31T01:43:24+05:00</updated>
    <id>http://blog.popstas.ru/blog/2016/01/31/timer-in-browser-with-1-second-time-to-start</id>
    <content type="html"><![CDATA[<p>Бывает, что надо вспомнить о чем-то в ближайшее время: выключить чайник, выйти к подъезду через 10 минут,
бросить заниматься фигней через полчаса - для таких вещей идеально подходит таймер. От таймера требуется только одно:
возможность установить его в течение 5 секунд. Недавно я нашел такой с такими плюсами:</p>

<ul>
<li>Настроить нужно один раз, после этого будет работать на всех системах, если включена синхронизация настроек браузера</li>
<li>Пользоваться легко</li>
</ul>


<p><img src="http://blog.popstas.ru/images/2016-01/eggtimer.png"></p>

<!-- more -->


<p><a href="http://e.ggtimer.com">http://e.ggtimer.com</a> - с виду ничего особенного (так и есть), мне понравилась простота и задание времени через URL.
Какое-то время я пользовался им так: создал 2 таймера, на 5 и на 10 минут, сделал на них закладки на панель закладок.
Это не очень удобно по 2 причинам: на chrome мне жалко места на панели, а на firefox у меня панели закладок нет.</p>

<p>Выход такой: оба браузера поддерживают пользовательские поисковые системы, сделаем такие.</p>

<h3>Firefox</h3>

<ol>
<li>Добавить в закладки <a href="http://e.ggtimer.com/%smin">http://e.ggtimer.com/%smin</a></li>
<li>Находим эту закладку в списке и делаем ей Keyword: t</li>
</ol>


<h3>Chrome</h3>

<ol>
<li>Настройки - Настроить поисковые системы</li>
<li>Добавить систему <code>e.ggtimer</code> - <code>t</code> - <code>http://e.ggtimer.com/%smin</code></li>
</ol>


<p>После этого таймер на 5 минут ставится так:</p>

<ol>
<li>Выбираем любой браузер</li>
<li>Ставим фокус на поисковую строку (<code>F6</code> / <code>Ctrl+L</code>)</li>
<li>Пишем <code>t 5</code>, <code>Enter</code></li>
</ol>


<p>На самом деле в Firefox не синхронизируется Keyword закладок, придется прописывать на каждой системе.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Автоматическое скачивание торрентов с Weburg в Transmission и статистика на InfluxDB & Grafana]]></title>
    <link href="http://blog.popstas.ru/blog/2016/01/17/torrent-transmission-client-for-weburg/"/>
    <updated>2016-01-17T08:22:25+05:00</updated>
    <id>http://blog.popstas.ru/blog/2016/01/17/torrent-transmission-client-for-weburg</id>
    <content type="html"><![CDATA[<p>У моего интернет-провайдера Планета есть бонусная программа поощрения раздачи торрентов с <a href="http://weburg.net">weburg.net</a>, дающая бонусы,
их можно тратить на абонентскую плату. У меня комп постоянно включен, я сразу стал участвовать.</p>

<p>Поддержку раздач можно разбить на несколько задач:</p>

<ol>
<li>периодически скачивать новинки фильмов</li>
<li>скачивать новые серии популярных сериалов</li>
<li>удалять то, что плохо раздается</li>
</ol>


<p>Через пару месяцев мне это надоело, задумался об автоматизации этого процесса и вот в новогодние каникулы родился
<a href="https://github.com/popstas/transmission-cli">transmission-cli</a> - консольная утилита, решающая часть этих задач.</p>

<iframe src="https://ghbtns.com/github-btn.html?user=popstas&repo=transmission-cli&type=star&count=true&size=large" frameborder="0" scrolling="0" width="160px" height="30px"></iframe>


<p><a href="https://travis-ci.org/popstas/transmission-cli"><img src="https://travis-ci.org/popstas/transmission-cli.svg?branch=master" alt="Build Status" /></a>
<a href="https://coveralls.io/github/popstas/transmission-cli?branch=master"><img src="https://coveralls.io/repos/popstas/transmission-cli/badge.svg?branch=master&amp;service=github" alt="Coverage Status" /></a></p>

<p><img src="https://github.com/popstas/transmission-cli/raw/master/doc/img/grafana.png?raw=true"></p>

<!-- more -->


<h2>Возможности</h2>

<ul>
<li>скачивание популярных торрентов с <a href="http://weburg.net">http://weburg.net</a></li>
<li>удаление дублирующихся раздач (для сериалов)</li>
<li>отправка метрик в InfluxDB (для слежения за популярностью)</li>
</ul>


<h1>Установка</h1>

<p>Установить клиент можно так:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">latest_phar</span><span class="o">=</span><span class="k">$(</span>curl -s https://api.github.com/repos/popstas/transmission-cli/releases/latest <span class="p">|</span> grep <span class="s1">&#39;browser_&#39;</span> <span class="p">|</span> cut -d<span class="se">\&quot;</span> -f4<span class="k">)</span>
</span><span class='line'>wget -O /usr/local/bin/transmission-cli <span class="s2">&quot;$latest_phar&quot;</span>
</span><span class='line'>chmod +x /usr/local/bin/transmission-cli
</span></code></pre></td></tr></table></div></figure>


<p>Пользоваться графиками можно с трудом, потому что InfluxDB и Grafana вам придется устанавливать самостоятельно.
Я ставил то и другое в docker на свою виртуалку и пробрасывал порты на localhost,
сейчас localhost вшит в <a href="https://github.com/popstas/transmission-cli/blob/master/src/Config.php">конфиг</a>,
который по сути сейчас находится в коде.</p>

<p>Поставить можно так, заменив папки <code>/Users/popstas/lib/grafana</code> и <code>/var/lib/influxdb</code> на ваши,
это укажет, где будут храниться данные InfluxDB и Grafana:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>docker run -d <span class="se">\ </span>-p 3000:3000 <span class="se">\</span>
</span><span class='line'>           -v /Users/popstas/lib/grafana:/var/lib/grafana <span class="se">\</span>
</span><span class='line'>            --name grafana grafana/grafana
</span><span class='line'>
</span><span class='line'>docker run -d -p 8083:8083 -p 8086:8086 <span class="se">\</span>
</span><span class='line'>           -v /var/lib/influxdb:/data <span class="se">\</span>
</span><span class='line'>           --name influxdb tutum/influxdb
</span></code></pre></td></tr></table></div></figure>


<p>Папку от InfluxDB я оставил в виртуалке, т.к. оказалось, что InfluxDB не может работать с папкой, смонтированной в
VirtualBox из Mac OS (какой-то старый глюк docker).</p>

<p>Чтобы собиралась статистика, нужно добавить в cron задания, я собираю с 2 компов, поэтому добавляю 2 раза.</p>

<p>Также, чтобы не было конфликтов, статистика не будет отсылаться, если найдет раздачи с одинаковыми названиями,
которые обычно остаются от сериалов. Поэтому их нужно чистить перед отпправкой статистики.</p>

<p>Раздачи у меня скачиваются в папку, за которой следят оба Transmission, как только туда попадает торрент, раздача
сразу начинается (можно сделать, чтобы спрашивала разрешение, настраивается в Transmission).</p>

<p>В итоге у меня получился такой cron:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;$PATH:/usr/local/bin&quot;</span>
</span><span class='line'><span class="m">59</span> * * * * transmission-cli remove-duplicates --host<span class="o">=</span>localhost
</span><span class='line'><span class="m">59</span> * * * * transmission-cli remove-duplicates --host<span class="o">=</span>wrtnsq
</span><span class='line'><span class="m">0</span>  * * * * transmission-cli send-metrics --host<span class="o">=</span>localhost
</span><span class='line'><span class="m">0</span>  * * * * transmission-cli send-metrics --host<span class="o">=</span>wrtnsq
</span><span class='line'><span class="m">1</span>  <span class="m">2</span> * * * transmission-cli download-weburg --dest<span class="o">=</span>/Volumes/media/_planeta/_torrents
</span></code></pre></td></tr></table></div></figure>


<h2>Результаты статистики</h2>

<p>Никогда не знал о своих раздачах ничего, кроме рейтинга и объема розданного за все время.
Графики показали интересные вещи (о которых можно было и так догадаться):</p>

<ul>
<li>с 18 до 22 пик раздач, с 22 до 2 спад, с 2 до 9 все спят</li>
<li>в праздники и выходные больше качают днем и до ночи, но после 2 все равно все спят</li>
<li>популярные фильмы популярны обычно не больше недели</li>
<li>есть популярные фильмы, которые популярны и через несколько месяцев, например &ldquo;Интерстеллар&rdquo;</li>
</ul>


<p>Сейчас я могу выбрать в Grafana период в 7 дней, отсортировать раздачи по розданным Гб и получить список
раздач-кандидатов на удаление.</p>

<p>Со статистикой еще надо работать, что еще хочется сделать:</p>

<ul>
<li><p>нормальную группировку по периодам, сейчас группируется только за час или за весь выбранный период,
нельзя выбрать последнюю неделю и посмотреть посуточные метрики. Я скидываю метрики и сначала не понимал,
почему так, но тут как раз вышла статья
<a href="http://habrahabr.ru/post/274303/">Почему расчет перцентилей работает не так как вы ожидаете?</a> и многое мне объяснила.</p></li>
<li><p>добавить в метрики инфу о весе раздач и вывести эффективность раздач: например, фильм в 1080p весом в 10 Гб
скачали на 50 Гб за неделю, а 2 Гб фильм низкого качества скачали на 10 Гб, если не учитывать вес раздач, то выходит,
что первая раздача в 5 раз эффективнее, но если учитвать, то оказвается, что они равны.</p></li>
</ul>


<h2>Техническая часть:</h2>

<ul>
<li>Symfony console - каркас консольной утилиты</li>
<li>InfluxDB - хранилище метрик</li>
<li>Grafana - рисование графиков</li>
<li>Composer - управление зависимостями</li>
<li>Box - <a href="http://habrahabr.ru/post/274745/">сборка PHAR</a></li>
<li>PHPCS, PHPMD - линтеры PHP</li>
<li>Travis CI - публицация PHAR на Github</li>
<li>Coveralls - сервис слежения за покрытием кода тестами</li>
</ul>


<p>Половину из этого я ни разу не использовал, вторую половину - немного. Поэтому граблей хватает.</p>

<h3>Symfony console</h3>

<p>Тут мне сказать особо нечего, фреймворки я только начинаю осваивать, пока ничего не понятно с Dependency Injection,
чувствую, что у меня переменные в функции местами прокидываются криво, а местами не прокидываются, где стоило бы.</p>

<p>Не понятно, как тестить через PHPUnit, как мокать объекты.</p>

<p>Пока радуюсь, что освоился с namespaces и использовал на практике PSR-2 и PSR-4.</p>

<p>Почти все идеи взяты из исходников
<a href="https://github.com/composer/composer">composer</a> и
<a href="https://github.com/MartialGeek/transmission-api">transmission-api</a></p>

<h3>InfluxDB</h3>

<p>InfluxDB не может работать с папкой, смонтированной в VirtualBox из Mac OS (какой-то старый глюк docker).</p>

<p>InfluxDB я раньше не видел, хотел посмотреть ее как замену для хранилища Whisper из стека
Diamond -> Carbon -> Whisper -> Graphite -> Grafana для рисования графиков сервера.</p>

<p>Компания, стоящая за InfluxDB с недавнего времени назвается InfluxData и предлагает свой стек
<a href="https://influxdata.com/time-series-platform/">TICK</a>, в который
входит еще и алертинг по отклонениям метрик. Могу сказать о нем то, что Telegraf работает, InfluxDB работает без тормозов,
собирая с моего компа метрики раз в 10 секунд, Chronograf какой-то неполноценный, по сравнению с Grafana,
а Kapacitor я еще не смотрел.</p>

<h3>Grafana</h3>

<p>В Grafana 2.6 появилось много нового, по сравнению с 2.0, которую я видел в августе. А вообще, если кто использовал
Cacti или Graphite и не видел Grafana, посмотрите, красота неописуемая.</p>

<h3>Composer</h3>

<p>Некоторые dev-пакеты (phpunit) потребовали php 5.6 для запуска, поэтому поставил 5.6 минимальной необходимой версией,
хотя по факту клиент может работать и на 5.5, а на 5.4 уже не может.</p>

<h3>Box</h3>

<p>Если собирать PHAR, используя box, установленный через composer, в архив попадает много ненужных dev-пакетов.
Сначала я пытался бороться с этим исключением пакетов через box.json, потом понял, что это бесполезно
(все пакеты не исключишь, а однажды исключишь нужный), в итоге пришел к такой схеме:</p>

<ul>
<li>ставим пакеты через <code>composer install --no-dev</code></li>
<li>качаем box.phar</li>
<li>собираем transmission-cli.phar</li>
<li>доставляем пакеты через composer update</li>
</ul>


<p>Это в 3 раза уменьшило вес собранного архива.</p>

<h3>PHPCS, PHPMD</h3>

<p>PHP Code Sniffer умеет анализировать ваш код на соответствие определенным стандартам, в моем случае PSR-2,
ставится через Composer, используется так:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>./vendor/bin/phpcs --standard<span class="o">=</span>psr2 ./src
</span></code></pre></td></tr></table></div></figure>


<p>А PHP Mess Detector у меня не запустился.</p>

<h3>Travis CI</h3>

<p>Впервые удалось использовать его по назначению. Как-то пробовал использовать его для тестов пакета bash скриптов
<a href="https://github.com/popstas/drupal-scripts">drupal-scripts</a>, но быстро сдался, т.к. в окружении travis они вели себя не так,
как на локалке (в итоге перекинул тесты на TeamCity).</p>

<p>На этом проекте travis прогоняет тесты phpunit
(тестов по сути еще нет, но без phpunit в каком-либо виде travis по умолчанию фейлит сборку)
и если к коммиту был проставлен git tag,
публикует PHAR как приложение к релизу на Github, чуть подробнее я написал
в <a href="http://habrahabr.ru/post/274745/#comment_8736379">этом комменте</a>.</p>

<h3>Coveralls</h3>

<p>До покрытия тестами я еще не добирался, я тесты-то еще только начинаю использовать, решил попробовать на этом проекте.</p>

<p>Чтобы добавить coveralls в самом простом случае (в доках есть и сложные), достаточно сделать так, чтобы PHPUnit
генерил файл <code>build/logs/clover.xml</code>, для этого надо добавить строчку в phpunit.xml, в секцию logging:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;logging&gt;</span>
</span><span class='line'>    <span class="nt">&lt;log</span> <span class="na">type=</span><span class="s">&quot;coverage-clover&quot;</span> <span class="na">target=</span><span class="s">&quot;build/logs/clover.xml&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/logging&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ну и конечно зарегаться на <a href="https://coveralls.io/">https://coveralls.io/</a> и активировать там проект.
Если путь будет другой, придется читать доки и создавать файл настройки .coveralls.yml</p>

<p>В результате я имею красивую красную ачивку на странице проекта
и <a href="https://coveralls.io/github/popstas/transmission-cli">историю деградации покрытия</a> :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Быстрое обновление PhpStorm EAP на Mac OS через Bash]]></title>
    <link href="http://blog.popstas.ru/blog/2016/01/17/automacic-update-phpstorm-eap-on-mac-os/"/>
    <updated>2016-01-17T07:50:17+05:00</updated>
    <id>http://blog.popstas.ru/blog/2016/01/17/automacic-update-phpstorm-eap-on-mac-os</id>
    <content type="html"><![CDATA[<p>Надоело постоянно обновлять PhpStorm руками. На Ubuntu последнее время делал это с помощью ansible,
под Mac этот плейбук не расчитан, к тому же версию ему надо было указвать вручную.
Поэтому написал скрипт, не совместимый с Ubuntu :)</p>

<p><img src="http://blog.jetbrains.com/phpstorm/files/2016/01/PhpStorm11EAP_splash_2@2x.png"></p>

<!-- more -->


<p>Что он делает:</p>

<ul>
<li>идет на страницу EAP, находит там версию</li>
<li>проверяет, что на компе стоит другая версия EAP</li>
<li>качает dmg в папку Загрузки</li>
<li>монтирует образ</li>
<li>завершает PhpStorm, если он открыт</li>
<li>удаляет текущую версию и копирует новую в папку /Applications</li>
<li>запускает новую версию</li>
</ul>


<p>Поставить можно так:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -s "https://gist.githubusercontent.com/popstas/613a72a34576b85caec4/raw/644f457ed0187ab0d1207576e925c06260451131/phpstorm-eap-update.sh" &gt; /usr/local/bin/phpstorm-eap-update
</span><span class='line'>chmod +x /usr/local/bin/phpstorm-eap-update</span></code></pre></td></tr></table></div></figure>


<p>После чего можно обновлять просто запуском <code>phpstorm-eap-update</code>.
По идее можно даже в cron его засунуть, чтобы совсем автомат, но я и так узнаю о новой версии из rss.</p>

<p>Код лежит здесь - <a href="https://gist.github.com/popstas/613a72a34576b85caec4">https://gist.github.com/popstas/613a72a34576b85caec4</a></p>

<p>В PhpStorm 11 из фич ничего особенного не нашел, зато с этой версии он перешел на использование Java 8,
не знаю, в этом ли дело, но у меня он вроде перестал тормозить.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Интерактивная Zsh History с поиском и скроллом, Percol]]></title>
    <link href="http://blog.popstas.ru/blog/2015/12/10/interactive-bash-history-with-search/"/>
    <updated>2015-12-10T19:55:20+05:00</updated>
    <id>http://blog.popstas.ru/blog/2015/12/10/interactive-bash-history-with-search</id>
    <content type="html"><![CDATA[<p>Если кто не знает, в bash/zsh есть поиск по истории комманд, если нажать <code>Ctrl+R</code> и начать набирать
команду, отобразится последняя команда из истории, для навигации можно использовать
<code>Ctrl+R</code>, <code>Ctrl+Shift+R</code>. При этом видно одновременно видно только одну команду из истории.</p>

<p>Утилита <a href="https://github.com/mooz/percol#zsh-history-search">percol</a> решает эту проблему.</p>

<p><img src="http://blog.popstas.ru/images/2015-12/percol.gif"></p>

<!-- more -->


<p>Собственно по ссылке выше готовый конфиг для zsh. Я немного изменил его под себя,
чтобы использовать percol не только для поиска по истории:</p>

<figure class='code'><figcaption><span>zsh-percol</span><a href='https://github.com/popstas/zsh-config/blob/master/.zshrc'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="k">function</span> exists <span class="o">{</span> which <span class="nv">$1</span> <span class="p">&amp;</span>&gt; /dev/null <span class="o">}</span>
</span><span class='line'><span class="k">if</span> exists percol<span class="p">;</span> <span class="k">then</span>
</span><span class='line'>  <span class="k">function</span> percol_select_history<span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="nb">local </span>tac
</span><span class='line'>      exists gtac <span class="o">&amp;&amp;</span> <span class="nv">tac</span><span class="o">=</span><span class="s2">&quot;gtac&quot;</span> <span class="o">||</span> <span class="o">{</span> exists tac <span class="o">&amp;&amp;</span> <span class="nv">tac</span><span class="o">=</span><span class="s2">&quot;tac&quot;</span> <span class="o">||</span> <span class="o">{</span> <span class="nv">tac</span><span class="o">=</span><span class="s2">&quot;tail -r&quot;</span> <span class="o">}</span> <span class="o">}</span>
</span><span class='line'>      <span class="nv">BUFFER</span><span class="o">=</span><span class="k">$(</span><span class="nb">fc</span> -l -n <span class="m">1</span> <span class="p">|</span> <span class="nb">eval</span> <span class="nv">$tac</span> <span class="p">|</span> percol --query <span class="s2">&quot;$LBUFFER&quot;</span><span class="k">)</span>
</span><span class='line'>      <span class="nv">CURSOR</span><span class="o">=</span><span class="nv">$#BUFFER</span>         <span class="c"># move cursor</span>
</span><span class='line'>      zle -R -c               <span class="c"># refresh</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  zle -N percol_select_history
</span><span class='line'>  bindkey <span class="s1">&#39;^R&#39;</span> percol_select_history
</span><span class='line'>
</span><span class='line'>  <span class="c"># percol based grep</span>
</span><span class='line'>  g<span class="o">()</span> <span class="o">{</span> percol --match-method regex --query<span class="o">=</span><span class="s2">&quot;$*&quot;</span><span class="p">;</span> <span class="o">}</span>
</span><span class='line'><span class="k">fi</span>
</span></code></pre></td></tr></table></div></figure>


<p>Код я добавил в <a href="https://github.com/popstas/zsh-config">свой .zshrc</a>. Если <a href="https://github.com/robbyrussell/oh-my-zsh/pull/4582">этот пулл реквест</a> примут, то данный код появится в составе
<a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a> в виде плагина <code>percol</code>.</p>

<p>Код полностью взят со страницы percol, от себя добавил функцию g(), она кстати конфиликтует с плагином git для oh-my-zsh,
зато теперь я могу писать что-то вроде:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>find . -type file <span class="p">|</span> g
</span></code></pre></td></tr></table></div></figure>


<p>для интерактивного выбора результатов поиска и просто для замены grep. При этом доступен мультивыбор по <code>Ctrl+Space</code>.</p>

<p>Пример посложнее:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>vim <span class="k">$(</span>find -name <span class="s2">&quot;*.markdown&quot;</span> <span class="p">|</span> g<span class="k">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>После запуска откроется список всех <code>.markdown</code> файлов в текущей и вложенных папках, выбранный файл сразу откроется в Vim.
Это как будто у вас появилась возможность приделывать midnight commander к результатам поиска!</p>

<p>Смотрите больше интересных примеров <a href="https://github.com/mooz/percol">на странице проекта</a>.</p>

<p>Надо сказать, что на github есть программы с таким же функционалом, как у percol, я об этом узнал на странице самого percol.
Там есть peco, клон percol на Go (а значит поставляется в виде одного бинарника). Мне проще через pip установить percol, так
что с аналогами не сравнивал.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Простой тайм-трекер для отслеживания потраченного времени]]></title>
    <link href="http://blog.popstas.ru/blog/2015/11/22/simple-time-tracker/"/>
    <updated>2015-11-22T09:40:45+05:00</updated>
    <id>http://blog.popstas.ru/blog/2015/11/22/simple-time-tracker</id>
    <content type="html"><![CDATA[<p>На работе у меня часто бывает такое, что не понятно, куда ушло время.
Поэтому написал для себя небольшое приложение, тайм-трекер - <a href="http://time.popstas.ru/">http://time.popstas.ru/</a>
Пользуюсь им уже 2 года, сегодня решил выложить на гитхаб и заодно исправил
глюки, которые раздражали последние годы :)</p>

<p><img src="https://github.com/popstas/time-tracker/raw/master/img/screenshot.png?raw=true"></p>

<!-- more -->


<p>Конечно, перед тем, как написать свое, долго искал что-то похожее.
Самое близкое, что нашел - <a href="https://www.toggl.com/">https://www.toggl.com/</a></p>

<p>Так как я собирался использовать ее постоянно и переключать задачу,
пока человек, прибежавший со срочной задачей ждет, важна была каждая секунда.</p>

<p>time-tracker - простая задачница, решающая большую задачу слежения за собой.</p>

<h3>Фичи:</h3>

<ul>
<li>быстрое добавление задач</li>
<li>подзадачи</li>
<li>быстрое переключение между задачами</li>
<li>исправление времени задним числом</li>
<li>быстрое копирование сводки за день</li>
<li>отслеживание времени по каждой задаче</li>
<li>сводка по задачам</li>
<li>навигация с клавиатуры</li>
</ul>


<h3>Неочевидные моменты</h3>

<ul>
<li>При отслеживании активна всегда только одна задача.</li>
<li>Если включить Desktop notifications, каждые 10 минут будет всплывать сообщение
о том, сколько активна задача с последнего ее запуска и сколько активна всего.</li>
<li>Единственный способ создать второй список задач - открыть другой браузер.</li>
</ul>


<h3>Сценарии применения</h3>

<ul>
<li>постоянное переключение между задачами в течение дня</li>
<li>многодневный проект, когда надо отследить общее потраченное время</li>
<li>быстрый чеклист</li>
</ul>


<p>Для многодневного проекта кстати хочу попробовать связку
<a href="https://trello.com/">Trello</a> + <a href="https://toggl.com/tools">Toggl</a>,
пока писал этот пост, узнал, что у них есть интеграция.</p>

<h3>Как я использую задачницу:</h3>

<p>Прихожу в офис, включаю задачу &ldquo;текучка&rdquo;
После этого ставлю фильтр, чтобы показались задачи с ненулевым временем,
выделяю все, вставляю в блокнот (потом можно вспомнить, чем занимался в
такой-то день, бывает полезно), сбрасываю таймеры (справа от строки ввода),
удаляю ненужное, добавляю то, что сегодня собираюсь делать (1-2 задачи) и
начинаю работать.</p>

<p>Когда ко мне кто-то приходит, и начинает задавать вопросы, я тут же запускаю
в задачах соответствующий проект или &ldquo;прочие консультации&rdquo;, если быстро определить
не удалось.</p>

<p>Чаще всего текущие проекты поделены на несколько подзадач, а внезапно возникающие
просто обозначены проектами.</p>

<h3>Мои постоянные задачи:</h3>

<ul>
<li><code>текучка</code> - вся не классифицируемая мелочь
разбор почты, разбор задач в корпоративной системе.</li>
<li><code>-------</code> - перекуры, наливание чая, прочее ничегонеделание</li>
<li><code>обед</code> - ничегонеделание в обед</li>
<li><code>прочие консультации</code> - разговоры на рабочие темы</li>
<li><code>сисадминство</code> - работы по серверу</li>
<li>несколько задач с проектами, которые постоянно всплывают</li>
</ul>


<h2>Техническая часть</h2>

<ul>
<li>Backbone (использовал в первый и последний раз)</li>
<li>LESS, шрифтовые иконки</li>
<li>Хранилище данных в LocalStorage браузера</li>
</ul>


<p>Одной из причин написать было желание потрогать backbone.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Показать все окна Gnome Terminal в Ubuntu]]></title>
    <link href="http://blog.popstas.ru/blog/2015/11/16/show-all-terminal-windows-in-ubuntu/"/>
    <updated>2015-11-16T23:55:17+05:00</updated>
    <id>http://blog.popstas.ru/blog/2015/11/16/show-all-terminal-windows-in-ubuntu</id>
    <content type="html"><![CDATA[<p>При работе за компом имею привычку открывать много терминалов,
не группируя их по вкладкам, рабочим столам или менеджером терминалов типа tmux.
При этом терминалы расположены по всему рабочему экрану.</p>

<p>Из-за этого была такая проблема: при переключении на браузер или редактор,
которые обычно занимают по полэкрана, все терминалы оказывались под большими окнами.</p>

<p>Придумал решение: нужно, чтобы можно было выбрать один терминал (который обычно доступен по Alt-Tab),
нажать хоткей и достать все окна этой же программы наверх.</p>

<!-- more -->


<h4>Для этого нужно:</h4>

<ul>
<li>определить текущее окно</li>
<li>определить его класс</li>
<li>найти все окна с тем же классом</li>
<li>активировать каждое из окон</li>
</ul>


<p>Для манипуляции с окнами из консоли использовал <code>xdotool</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>sudo aptitude install xdotool
</span></code></pre></td></tr></table></div></figure>


<p>Через полчаса родился страшный однострочник, в итоге из него получился такой скрипт:</p>

<figure class='code'><figcaption><span>windows-activate</span><a href='https://gist.github.com/popstas/9e1641e39abbda6392f1'>link</a></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'><span class="c"># </span>
</span><span class='line'><span class="c"># Activate all windows with process name of currently active window</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Получить текущее активное окно, его pid, имя процесса</span>
</span><span class='line'><span class="nv">current_pid</span><span class="o">=</span><span class="k">$(</span>xdotool getwindowpid <span class="k">$(</span>xdotool getactivewindow<span class="k">))</span>
</span><span class='line'><span class="nv">current_name</span><span class="o">=</span><span class="k">$(</span>ps -p <span class="nv">$current_pid</span> -o <span class="nv">comm</span><span class="o">=</span><span class="k">)</span>
</span><span class='line'><span class="nv">clean_name</span><span class="o">=</span><span class="k">${</span><span class="nv">current_name</span><span class="p">%-</span><span class="k">}</span>
</span><span class='line'>
</span><span class='line'><span class="nv">name</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="k">:-</span><span class="nv">$clean_name</span><span class="k">}</span>
</span><span class='line'>
</span><span class='line'><span class="c"># найти окна процесса (только видимые), активировать каждое из них</span>
</span><span class='line'>xdotool search --onlyvisible --class <span class="s2">&quot;$name&quot;</span> <span class="se">\</span>
</span><span class='line'>  <span class="p">|</span> xargs -L1 --no-run-if-empty xdotool windowactivate
</span></code></pre></td></tr></table></div></figure>


<h3>Какие были проблемы:</h3>

<ul>
<li>У каждого процесса оказалось штук по 5 &ldquo;окон&rdquo;, которые на самом деле не видны</li>
<li>Текущий процесс <code>gnome-terminal</code> виден в процессах как <code>gnome-terminal-server</code>,
в процессах имя не входит и отображается как <code>gnome-terminal-</code>,
в этом месте был вбит костыль, добавлена обрезка дефиса в конце.</li>
</ul>


<p>Скрипт был сохранен в /usr/local/bin/window-activate и через <code>ccsm</code> (Compiz config settings manager) повешен на хоткей.</p>

<p>Скрипт можно вызывать, передав параметром имя процесса, иначе возьмет его из текущего окна.</p>
]]></content>
  </entry>
  
</feed>
